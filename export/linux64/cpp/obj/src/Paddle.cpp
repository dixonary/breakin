// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_AI
#include <AI.h>
#endif
#ifndef INCLUDED_Ball
#include <Ball.h>
#endif
#ifndef INCLUDED_Glow
#include <Glow.h>
#endif
#ifndef INCLUDED_HitEmitter
#include <HitEmitter.h>
#endif
#ifndef INCLUDED_Input
#include <Input.h>
#endif
#ifndef INCLUDED_Level
#include <Level.h>
#endif
#ifndef INCLUDED_Mode
#include <Mode.h>
#endif
#ifndef INCLUDED_Paddle
#include <Paddle.h>
#endif
#ifndef INCLUDED_PlayState
#include <PlayState.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxGame
#include <flixel/FlxGame.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_effects_particles_FlxTypedEmitter
#include <flixel/effects/particles/FlxTypedEmitter.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_system_FlxSound
#include <flixel/system/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_DisplayObject
#include <openfl/_legacy/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_DisplayObjectContainer
#include <openfl/_legacy/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_IBitmapDrawable
#include <openfl/_legacy/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_InteractiveObject
#include <openfl/_legacy/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_Sprite
#include <openfl/_legacy/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl__legacy_events_EventDispatcher
#include <openfl/_legacy/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl__legacy_events_IEventDispatcher
#include <openfl/_legacy/events/IEventDispatcher.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_97ae16d9c540753c_11_new,"Paddle","new",0x0f94667c,"Paddle.new","Paddle.hx",11,0x43ccfc74)
HX_LOCAL_STACK_FRAME(_hx_pos_97ae16d9c540753c_67_resetPosition,"Paddle","resetPosition",0x06055eb4,"Paddle.resetPosition","Paddle.hx",67,0x43ccfc74)
HX_LOCAL_STACK_FRAME(_hx_pos_97ae16d9c540753c_73_update,"Paddle","update",0xb848a96d,"Paddle.update","Paddle.hx",73,0x43ccfc74)
HX_LOCAL_STACK_FRAME(_hx_pos_97ae16d9c540753c_13_boot,"Paddle","boot",0x8a5e4696,"Paddle.boot","Paddle.hx",13,0x43ccfc74)

void Paddle_obj::__construct(int P){
            	HX_GC_STACKFRAME(&_hx_pos_97ae16d9c540753c_11_new)
HXLINE(  23)		this->hits = (int)0;
HXLINE(  20)		this->max = (int)400;
HXLINE(  19)		this->speed = (int)5000;
HXLINE(  28)		super::__construct(null(),null(),null());
HXLINE(  29)		this->player = P;
HXLINE(  30)		int _hx_tmp = (::Paddle_obj::ballSize * (int)5);
HXDLIN(  30)		this->makeGraphic(_hx_tmp,::Std_obj::_hx_int(((Float)::Paddle_obj::ballSize / (Float)(int)2)),(int)-1,false,null());
HXLINE(  31)		int _hx_tmp1;
HXDLIN(  31)		if ((this->player == (int)0)) {
HXLINE(  31)			_hx_tmp1 = (int)16776960;
            		}
            		else {
HXLINE(  31)			_hx_tmp1 = (int)16711935;
            		}
HXDLIN(  31)		this->set_color(_hx_tmp1);
HXLINE(  33)		this->resetPosition();
HXLINE(  35)		 ::flixel::FlxSprite p =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,(int)0,(int)0,HX_("assets/images/pattern2.png",48,e2,53,e7));
HXLINE(  36)		Float _hx_tmp2 = -(::Math_obj::random());
HXDLIN(  36)		Float _hx_tmp3 = p->get_width();
HXDLIN(  36)		int _hx_tmp4 = (_hx_tmp2 * (_hx_tmp3 - this->get_width()));
HXDLIN(  36)		Float _hx_tmp5 = -(::Math_obj::random());
HXDLIN(  36)		Float _hx_tmp6 = p->get_height();
HXDLIN(  36)		this->stamp(p,_hx_tmp4,(_hx_tmp5 * (_hx_tmp6 - this->get_height())));
HXLINE(  38)		this->drag->set_x(this->speed);
HXLINE(  39)		this->maxVelocity->set_x(this->max);
HXLINE(  40)		this->set_immovable(true);
HXLINE(  42)		::Glow_obj::onlyGlow(hx::ObjectPtr<OBJ_>(this));
HXLINE(  44)		this->hum =  ::flixel::_hx_system::FlxSound_obj::__alloc( HX_CTX );
HXLINE(  45)		if ((this->player == (int)0)) {
HXLINE(  46)			this->hum->loadEmbedded(HX_("assets/sounds/hum.ogg",62,2d,d6,8e),true,null(),null());
            		}
            		else {
HXLINE(  48)			this->hum->loadEmbedded(HX_("assets/sounds/hum2.ogg",72,0e,3b,8f),true,null(),null());
            		}
HXLINE(  49)		this->hum->set_volume((int)0);
HXLINE(  50)		this->hum->play(null(),null(),null());
HXLINE(  52)		this->hit =  ::flixel::_hx_system::FlxSound_obj::__alloc( HX_CTX );
HXLINE(  53)		if ((this->player == (int)0)) {
HXLINE(  54)			this->hit->loadEmbedded(HX_("assets/sounds/hit.ogg",75,e8,5b,ca),null(),null(),null());
            		}
            		else {
HXLINE(  56)			this->hit->loadEmbedded(HX_("assets/sounds/hit2.ogg",ff,03,b9,68),null(),null(),null());
            		}
HXLINE(  58)		this->emitter =  ::HitEmitter_obj::__alloc( HX_CTX ,hx::ObjectPtr<OBJ_>(this),((((Float)0.5) - this->player) * (int)2));
HXLINE(  59)		::flixel::FlxG_obj::game->_state->add(this->emitter).StaticCast<  ::flixel::FlxBasic >();
HXLINE(  61)		if ((this->player < (int)0)) {
HXLINE(  62)			this->ai =  ::AI_obj::__alloc( HX_CTX ,hx::ObjectPtr<OBJ_>(this));
HXLINE(  63)			::flixel::FlxG_obj::game->_state->add(this->ai).StaticCast<  ::flixel::FlxBasic >();
            		}
            	}

Dynamic Paddle_obj::__CreateEmpty() { return new Paddle_obj; }

void *Paddle_obj::_hx_vtable = 0;

Dynamic Paddle_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Paddle_obj > _hx_result = new Paddle_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Paddle_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x18d0b88a) {
		if (inClassId<=(int)0x0b6ffd77) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x0b6ffd77;
		} else {
			return inClassId==(int)0x18d0b88a;
		}
	} else {
		return inClassId==(int)0x25a685e0 || inClassId==(int)0x2e105115;
	}
}

void Paddle_obj::resetPosition(){
            	HX_STACKFRAME(&_hx_pos_97ae16d9c540753c_67_resetPosition)
HXLINE(  68)		int _hx_tmp = ::flixel::FlxG_obj::width;
HXDLIN(  68)		this->set_x(((Float)(_hx_tmp - (::Paddle_obj::ballSize * (int)5)) / (Float)(int)2));
HXLINE(  69)		Float _hx_tmp1;
HXDLIN(  69)		if ((this->player == (int)0)) {
HXLINE(  69)			_hx_tmp1 = (int)20;
            		}
            		else {
HXLINE(  69)			int _hx_tmp2 = (::flixel::FlxG_obj::height - (int)20);
HXDLIN(  69)			_hx_tmp1 = (_hx_tmp2 - this->get_height());
            		}
HXDLIN(  69)		this->set_y(_hx_tmp1);
HXLINE(  70)		this->velocity->set((int)0,(int)0);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Paddle_obj,resetPosition,(void))

void Paddle_obj::update(Float d){
            	HX_STACKFRAME(&_hx_pos_97ae16d9c540753c_73_update)
HXLINE(  74)		this->super::update(d);
HXLINE(  76)		if (hx::IsEq( ::PlayState_obj::Mode,::Mode_obj::PLAYING_dyn() )) {
HXLINE(  77)			if (hx::IsNotNull( this->ai )) {
HXLINE(  78)				 ::flixel::math::FlxPoint _hx_tmp = this->acceleration;
HXDLIN(  78)				_hx_tmp->set_x((this->ai->cMove * this->speed));
            			}
            			else {
HXLINE(  81)				 ::flixel::math::FlxPoint _hx_tmp1 = this->acceleration;
HXDLIN(  81)				Float _hx_tmp2 = ::Input_obj::XAxis(this->player);
HXDLIN(  81)				_hx_tmp1->set_x((_hx_tmp2 * this->speed));
            			}
            		}
            		else {
HXLINE(  85)			 ::flixel::math::FlxPoint _hx_tmp3 = this->acceleration;
HXDLIN(  85)			_hx_tmp3->set_x(this->velocity->set_x((int)0));
            		}
HXLINE(  88)		if ((this->x < ::Level_obj::unit)) {
HXLINE(  89)			this->set_x(::Level_obj::unit);
HXLINE(  90)			 ::flixel::math::FlxPoint _hx_tmp4 = this->velocity;
HXDLIN(  90)			_hx_tmp4->set_x(::Math_obj::max((int)0,this->velocity->x));
            		}
HXLINE(  92)		Float _hx_tmp5 = this->x;
HXDLIN(  92)		int _hx_tmp6 = (::flixel::FlxG_obj::width - ::Level_obj::unit);
HXDLIN(  92)		if ((_hx_tmp5 > (_hx_tmp6 - this->get_width()))) {
HXLINE(  93)			int _hx_tmp7 = (::flixel::FlxG_obj::width - ::Level_obj::unit);
HXDLIN(  93)			this->set_x((_hx_tmp7 - this->get_width()));
HXLINE(  94)			 ::flixel::math::FlxPoint _hx_tmp8 = this->velocity;
HXDLIN(  94)			_hx_tmp8->set_x(::Math_obj::min((int)0,this->velocity->x));
            		}
HXLINE(  97)		{
HXLINE(  97)			int _g = (int)0;
HXDLIN(  97)			::Array< ::Dynamic> _g1 = ::Level_obj::Balls;
HXDLIN(  97)			while((_g < _g1->length)){
HXLINE(  97)				 ::Ball b = _g1->__get(_g).StaticCast<  ::Ball >();
HXDLIN(  97)				_g = (_g + (int)1);
HXLINE(  98)				if (::flixel::FlxG_obj::overlap(b,hx::ObjectPtr<OBJ_>(this),null(),null())) {
HXLINE(  99)					Float left = (this->x - b->x);
HXDLIN(  99)					Float left1 = (b->x - this->x);
HXDLIN(  99)					Float left2 = ::Math_obj::max(left,(left1 - this->get_width()));
HXLINE( 100)					Float top = (this->y - b->y);
HXDLIN( 100)					Float top1 = (b->y - this->y);
HXDLIN( 100)					Float top2 = ::Math_obj::max(top,(top1 - this->get_height()));
HXLINE( 102)					if ((left2 < top2)) {
HXLINE( 103)						Float hitR = this->get_width();
HXLINE( 104)						Float hitL = -(b->get_width());
HXLINE( 106)						Float hitW = (hitR - hitL);
HXLINE( 107)						Float newAngle = (((((Float)((b->x - this->x) - hitL) / (Float)hitW) - ((Float)0.5)) * ::Math_obj::PI) * ((Float)0.8));
HXLINE( 108)						Float _hx_tmp9 = ::Math_obj::abs(newAngle);
HXDLIN( 108)						if ((_hx_tmp9 < ((Float)::Math_obj::PI / (Float)(int)60))) {
HXLINE( 109)							int newAngle1;
HXDLIN( 109)							if ((::Math_obj::random() < ((Float)0.5))) {
HXLINE( 109)								newAngle1 = (int)1;
            							}
            							else {
HXLINE( 109)								newAngle1 = (int)-1;
            							}
HXLINE( 108)							newAngle = ((((::Math_obj::random() + (int)1) * ::Math_obj::PI) * ((Float)0.4)) * newAngle1);
            						}
HXLINE( 111)						 ::flixel::math::FlxPoint b1 = b->velocity;
HXDLIN( 111)						Float _hx_tmp10 = ::Ball_obj::Speed;
HXDLIN( 111)						b1->set_x((_hx_tmp10 * ::Math_obj::sin(newAngle)));
HXLINE( 112)						 ::flixel::math::FlxPoint b2 = b->velocity;
HXDLIN( 112)						Float _hx_tmp11 = (::Ball_obj::Speed * (int)2);
HXDLIN( 112)						Float _hx_tmp12 = (_hx_tmp11 * ::Math_obj::cos(newAngle));
HXDLIN( 112)						b2->set_y((_hx_tmp12 * (((Float)0.5) - this->player)));
HXLINE( 114)						this->hits++;
HXLINE( 115)						 ::flixel::_hx_system::FlxSound _hx_tmp13 = this->hit;
HXDLIN( 115)						_hx_tmp13->set_volume(::Math_obj::min(((Float)this->hits / (Float)(int)10),((Float)0.8)));
HXLINE( 116)						this->hit->play(true,null(),null());
HXLINE( 117)						this->emitter->start(true,null(),null());
HXLINE( 118)						if (hx::IsNotNull( this->ai )) {
HXLINE( 118)							this->ai->nextMove();
            						}
            					}
            					else {
HXLINE( 121)						if ((b->x < this->x)) {
HXLINE( 121)							 ::flixel::math::FlxPoint b3 = b->velocity;
HXDLIN( 121)							b3->set_x(((int)-1 * ::Math_obj::abs(b->velocity->x)));
            						}
            						else {
HXLINE( 122)							 ::flixel::math::FlxPoint b4 = b->velocity;
HXDLIN( 122)							b4->set_x(::Math_obj::abs(b->velocity->x));
            						}
            					}
            				}
            			}
            		}
HXLINE( 128)		 ::flixel::_hx_system::FlxSound _hx_tmp14 = this->hum;
HXDLIN( 128)		_hx_tmp14->set_volume((::Math_obj::abs(((Float)this->velocity->x / (Float)this->maxVelocity->x)) * (int)0));
HXLINE( 129)		this->emitter->x = this->x;
HXLINE( 130)		Float _hx_tmp15 = this->y;
HXDLIN( 130)		int _hx_tmp16 = ((int)1 - this->player);
HXDLIN( 130)		Float _hx_tmp17 = (_hx_tmp16 * this->get_height());
HXDLIN( 130)		this->emitter->y = (_hx_tmp15 + _hx_tmp17);
            	}


int Paddle_obj::ballSize;


hx::ObjectPtr< Paddle_obj > Paddle_obj::__new(int P) {
	hx::ObjectPtr< Paddle_obj > __this = new Paddle_obj();
	__this->__construct(P);
	return __this;
}

hx::ObjectPtr< Paddle_obj > Paddle_obj::__alloc(hx::Ctx *_hx_ctx,int P) {
	Paddle_obj *__this = (Paddle_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Paddle_obj), true, "Paddle"));
	*(void **)__this = Paddle_obj::_hx_vtable;
	__this->__construct(P);
	return __this;
}

Paddle_obj::Paddle_obj()
{
}

void Paddle_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Paddle);
	HX_MARK_MEMBER_NAME(hum,"hum");
	HX_MARK_MEMBER_NAME(hit,"hit");
	HX_MARK_MEMBER_NAME(emitter,"emitter");
	HX_MARK_MEMBER_NAME(speed,"speed");
	HX_MARK_MEMBER_NAME(max,"max");
	HX_MARK_MEMBER_NAME(ai,"ai");
	HX_MARK_MEMBER_NAME(hits,"hits");
	HX_MARK_MEMBER_NAME(player,"player");
	 ::flixel::FlxSprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Paddle_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(hum,"hum");
	HX_VISIT_MEMBER_NAME(hit,"hit");
	HX_VISIT_MEMBER_NAME(emitter,"emitter");
	HX_VISIT_MEMBER_NAME(speed,"speed");
	HX_VISIT_MEMBER_NAME(max,"max");
	HX_VISIT_MEMBER_NAME(ai,"ai");
	HX_VISIT_MEMBER_NAME(hits,"hits");
	HX_VISIT_MEMBER_NAME(player,"player");
	 ::flixel::FlxSprite_obj::__Visit(HX_VISIT_ARG);
}

hx::Val Paddle_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"ai") ) { return hx::Val( ai ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"hum") ) { return hx::Val( hum ); }
		if (HX_FIELD_EQ(inName,"hit") ) { return hx::Val( hit ); }
		if (HX_FIELD_EQ(inName,"max") ) { return hx::Val( max ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"hits") ) { return hx::Val( hits ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"speed") ) { return hx::Val( speed ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"player") ) { return hx::Val( player ); }
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"emitter") ) { return hx::Val( emitter ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"resetPosition") ) { return hx::Val( resetPosition_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Paddle_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"ballSize") ) { outValue = ( ballSize ); return true; }
	}
	return false;
}

hx::Val Paddle_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"ai") ) { ai=inValue.Cast<  ::AI >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"hum") ) { hum=inValue.Cast<  ::flixel::_hx_system::FlxSound >(); return inValue; }
		if (HX_FIELD_EQ(inName,"hit") ) { hit=inValue.Cast<  ::flixel::_hx_system::FlxSound >(); return inValue; }
		if (HX_FIELD_EQ(inName,"max") ) { max=inValue.Cast< int >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"hits") ) { hits=inValue.Cast< int >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"speed") ) { speed=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"player") ) { player=inValue.Cast< int >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"emitter") ) { emitter=inValue.Cast<  ::flixel::effects::particles::FlxTypedEmitter >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Paddle_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"ballSize") ) { ballSize=ioValue.Cast< int >(); return true; }
	}
	return false;
}

void Paddle_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("hum","\xc0","\x50","\x4f","\x00"));
	outFields->push(HX_HCSTRING("hit","\x53","\x46","\x4f","\x00"));
	outFields->push(HX_HCSTRING("emitter","\x6e","\x35","\xf6","\xbe"));
	outFields->push(HX_HCSTRING("speed","\x87","\x97","\x69","\x81"));
	outFields->push(HX_HCSTRING("max","\xa4","\x0a","\x53","\x00"));
	outFields->push(HX_HCSTRING("ai","\xe8","\x54","\x00","\x00"));
	outFields->push(HX_HCSTRING("hits","\xc0","\x42","\x0e","\x45"));
	outFields->push(HX_HCSTRING("player","\x61","\xeb","\xb8","\x37"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Paddle_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::flixel::_hx_system::FlxSound*/ ,(int)offsetof(Paddle_obj,hum),HX_HCSTRING("hum","\xc0","\x50","\x4f","\x00")},
	{hx::fsObject /*::flixel::_hx_system::FlxSound*/ ,(int)offsetof(Paddle_obj,hit),HX_HCSTRING("hit","\x53","\x46","\x4f","\x00")},
	{hx::fsObject /*::flixel::effects::particles::FlxTypedEmitter*/ ,(int)offsetof(Paddle_obj,emitter),HX_HCSTRING("emitter","\x6e","\x35","\xf6","\xbe")},
	{hx::fsInt,(int)offsetof(Paddle_obj,speed),HX_HCSTRING("speed","\x87","\x97","\x69","\x81")},
	{hx::fsInt,(int)offsetof(Paddle_obj,max),HX_HCSTRING("max","\xa4","\x0a","\x53","\x00")},
	{hx::fsObject /*::AI*/ ,(int)offsetof(Paddle_obj,ai),HX_HCSTRING("ai","\xe8","\x54","\x00","\x00")},
	{hx::fsInt,(int)offsetof(Paddle_obj,hits),HX_HCSTRING("hits","\xc0","\x42","\x0e","\x45")},
	{hx::fsInt,(int)offsetof(Paddle_obj,player),HX_HCSTRING("player","\x61","\xeb","\xb8","\x37")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Paddle_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &Paddle_obj::ballSize,HX_HCSTRING("ballSize","\x60","\x1a","\xf0","\x3b")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Paddle_obj_sMemberFields[] = {
	HX_HCSTRING("hum","\xc0","\x50","\x4f","\x00"),
	HX_HCSTRING("hit","\x53","\x46","\x4f","\x00"),
	HX_HCSTRING("emitter","\x6e","\x35","\xf6","\xbe"),
	HX_HCSTRING("speed","\x87","\x97","\x69","\x81"),
	HX_HCSTRING("max","\xa4","\x0a","\x53","\x00"),
	HX_HCSTRING("ai","\xe8","\x54","\x00","\x00"),
	HX_HCSTRING("hits","\xc0","\x42","\x0e","\x45"),
	HX_HCSTRING("player","\x61","\xeb","\xb8","\x37"),
	HX_HCSTRING("resetPosition","\x98","\x8d","\x99","\xfb"),
	HX_HCSTRING("update","\x09","\x86","\x05","\x87"),
	::String(null()) };

static void Paddle_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Paddle_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Paddle_obj::ballSize,"ballSize");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Paddle_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Paddle_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Paddle_obj::ballSize,"ballSize");
};

#endif

hx::Class Paddle_obj::__mClass;

static ::String Paddle_obj_sStaticFields[] = {
	HX_HCSTRING("ballSize","\x60","\x1a","\xf0","\x3b"),
	::String(null())
};

void Paddle_obj::__register()
{
	hx::Object *dummy = new Paddle_obj;
	Paddle_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("Paddle","\x8a","\xb8","\xd0","\x18");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Paddle_obj::__GetStatic;
	__mClass->mSetStaticField = &Paddle_obj::__SetStatic;
	__mClass->mMarkFunc = Paddle_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Paddle_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Paddle_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Paddle_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Paddle_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Paddle_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Paddle_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Paddle_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_97ae16d9c540753c_13_boot)
HXDLIN(  13)		ballSize = (int)20;
            	}
}

